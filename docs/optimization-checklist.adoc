1) Rule authoring & validation +  + 

[ ]	AND-only authoring enforced (no explicit OR; use IS_ANY_OF / IN-style operators).  + 

[ ]	Schema & types validated (operators allowed; field types match).  + 

[ ]	Contradictions rejected (e.g., field==A AND field==B).  + 

[ ]	Match-all prevention (empty conditions without event type are invalid).  + 

[ ]	Canonicalization (UPPER_SNAKE fields, normalized operators, trimmed strings).  + 

[ ]	Dictionary encoding for fields/values (ints instead of strings).  + 

[ ]	Constant folding of static expressions.  ￼  + 


2) Predicate registry & factoring  + 

[ ]	Extract & ID all unique predicates; apply CSE to evaluate once per event.  + 

[ ]	Smart IS_ANY_OF factoring across the entire rule set (find common subsets once; reuse).  + 

[ ]	Strength reduction (e.g., IS_ANY_OF(1) → EQUAL_TO; simplify regex).  + 

[ ]	Selectivity & cost estimates computed; weights assigned.  + 

[ ]	Vectorization groups clustered by field for SIMD-friendly evaluation (Java Vector API).  ￼  + 

  + 

3) Selective DNF expansion  + 

[ ]	Detect IS_ANY_OF on same attribute within a logical rule (OR detection).  + 

[ ]	Expand with caps (configurable cartesian limits); deduplicate combos post-expansion.  + 

[ ]	Assign rule families (deterministic IDs, priorities).  + 

[ ]	Track expansion stats (p50/p95/p99/max) for capacity planning.  ￼  + 


4) Inverted index & bitmaps  + 

[ ]	Build predicate → rule posting lists.  + 

[ ]	Adaptive representation per density:  + 

[ ]	Dense >50% → bit array  + 

[ ]	Ultra-sparse <32 rules → sorted int array  + 

[ ]	Balanced → RoaringBitmap  + 

[ ]	Precompute stats (cardinality, density, selectivity).  + 

[ ]	64-byte alignment & co-occurrence grouping.  ￼  + 

  + 

5) Execution plan generation  + 

[ ]	Order predicates by weight (cost × (1−selectivity)).  + 

[ ]	Define stages (vectorized fast path → speculative → sequential).  + 

[ ]	Memory tiering plan (hot/warm/cold) + NUMA-aware layout.  + 

[ ]	Pre-allocate counters/touched lists.  ￼  + 


6) Runtime evaluation pipeline  + 

[ ]	Normalize event payloads (map to dictionary IDs).  + 

[ ]	Base-condition evaluation + distributed cache (evaluate once per unique static set; reuse across families).  + 

[ ]	Deduplicated predicate evaluation in weight order; skip already-evaluated.  + 

[ ]	Counter update only for touched rules; maintain touched list for O(touched) resets.  + 

[ ]	Match detection (counter vs. needs) then selection strategy (ALL_MATCHES / PER_FAMILY_MAX_PRIORITY / TOP_K).  + 

Operational targets: Base-set cache hit ≥ 95%; predicates evaluated/event < 1000 (steady-state).  ￼  + 


7) Memory management  + 

[ ]	SoA (Structure-of-Arrays) layout for counters/needs/metadata.  + 

[ ]	Off-heap for large bitmaps; memory-mapped immutable rule data.  + 

[ ]	Object pooling & thread-local working sets.  + 

[ ]	NUMA-aware allocation; tiered caching (hot via soft refs; warm via weak refs).  ￼  + 


8) Java 25 & JVM tuning  + 

[ ]	Compact object headers enabled (64-bit; expect 40–60% per-object memory reduction).  + 

[ ]	Scoped Values instead of ThreadLocal (15–30% concurrency gains; avoid leaks).  + 

[ ]	Vector API (Float16) for numeric predicates (aim ~2× throughput).  + 

[ ]	Generational ZGC, pauses < 5 ms; large pages; NUMA on.  + 

[ ]	Aggressive inlining (≈512-byte threshold).  + 

[ ]	JFR CPU-time profiling in prod (≈5% overhead).  ￼  + 

9) Deployment defaults (Cloud Run example)  +

[ ]	8 vCPU, 16 GB (≈12 GB heap; 4 GB direct mem).  + 

[ ]	Concurrency ≈ 100; throttling disabled; Gen2; startup CPU boost.  + 

[ ]	Blue-green deploys; zero-downtime rule-set rollover.  ￼  + 

  + 

10) Observability & alerts  + 

[ ]	Core metrics: events processed, matches, predicate evals, duration histogram, selectivity, bitmap density, cache hit, epoch version, rule count, memory.  + 

[ ]	Scale metrics: logical vs expanded counts; dedup effectiveness; memory per M combos; predicates/event; compile time per 10K rules.  + 

[ ]	Alerts:  + 

[ ]	Expansion factor > 10,000 (any rule)  + 

[ ]	Dedup rate < 60%  + 

[ ]	Memory growth > 100 MB / 10K rules  + 

[ ]	Compilation > 10 s / 10K rules  + 

[ ]	Base-cache hit < 90%  ￼  + 

  + 

11) Load & longevity tests  + 

[ ]	Baseline: 10K rules; 1M combos; 100K events/min.  + 

[ ]	Scale: 50K rules; 5M combos; 500K events/min.  + 

[ ]	Stress: 100K rules; 10M combos; 1M events/min.  + 

[ ]	Mixed complexity profiles (simple/medium/complex).  + 

[ ]	Sustained: 500K events/min × 24h @ 50K rules.  + 

[ ]	Burst: 2M events/min × 5 min.  + 

[ ]	Memory stability @ 100K rules < 4 GB; cache L1/L2/L3 hit >95%.  ￼  + 

  + 

12) Adaptive tuning loop (periodic, e.g., every ~100K events)  + 

[ ]	Reorder predicates by observed selectivity.  + 

[ ]	Morph bitmaps as density changes (array ↔ roaring ↔ bitset).  + 

[ ]	Tune base-cache size based on hit/miss and hot-set cardinality.  + 

[ ]	Track dedup effectiveness and expansion vs. estimates; adjust caps.  ￼  + 

  + 

13) Migration playbook  + 

[ ]	Shadow mode (compare outputs/perf; no prod effects).  + 

[ ]	Canary ramp: 1% → 5% → 20% → 50% → 100% with auto-rollback.  + 

[ ]	Feature flags by customer/rule type; A/B perf validation.  + 

[ ]	Cutover & keep legacy in standby; decommission after 2 stable weeks.  ￼  + 

  + 

14) Definition of Done (SLOs)  + 

[ ]	Throughput: 15–20M events/min sustained.  + 

[ ]	Latency: P99 < 0.8 ms @ 100K rules; P50 < 0.15 ms.  + 

[ ]	Memory: < 6 GB @ 100K rules (target 4–6 GB).  + 

[ ]	CPU: 90%+ efficiency; working set < 100 MB (fits in L3).  + 

[ ]	GC: pauses < 5 ms (Gen ZGC).  + 

[ ]	Uptime: 99.9% / 30 days; successful DR drill.  ￼  + 

  + 

