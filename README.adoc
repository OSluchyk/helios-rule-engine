= Helios Rule Engine: Developer Guide
:toc:
:toclevels: 3
:source-highlighter: rouge
:icons: font

== Overview

Helios is a high-performance rule engine designed to evaluate millions of events per minute against large rule sets (10K+ rules) with sub-millisecond latency. It achieves this through aggressive offline compilation, dictionary encoding, and deduplication.

**Key Features:**
* Sub-millisecond P99 latency even with 10,000+ rules
* 90%+ deduplication rate for rules with shared conditions
* Hot reload support (zero-downtime rule updates)
* Comprehensive observability with OpenTelemetry
* Production-ready with Caffeine caching (75%+ hit rate)

---

== Quick Start

=== Prerequisites

* JDK 25 or higher
* Apache Maven 3.8+

=== Build and Run

[source,bash]
----
# Clone and build
git clone https://github.com/your-org/helios-rule-engine.git
cd helios-rule-engine
mvn clean package

# Run the server
java -jar target/rule-engine-1.0.0.jar

# Server starts on http://localhost:8080
----

=== Your First Rule Evaluation

1. **Create a rules file** (`rules.json`):
+
[source,json]
----
[
  {
    "rule_code": "HIGH_VALUE_ORDER",
    "priority": 100,
    "description": "Flag high-value orders from premium customers",
    "conditions": [
      {"field": "order_amount", "operator": "GREATER_THAN", "value": 10000},
      {"field": "customer_tier", "operator": "EQUAL_TO", "value": "PLATINUM"}
    ]
  },
  {
    "rule_code": "SUSPICIOUS_LOCATION",
    "priority": 200,
    "conditions": [
      {"field": "country", "operator": "IS_ANY_OF", "value": ["XX", "YY"]},
      {"field": "transaction_count", "operator": "GREATER_THAN", "value": 5}
    ]
  }
]
----

2. **Compile the rules** (happens automatically on startup, or manually):
+
[source,java]
----
RuleCompiler compiler = new RuleCompiler(tracer);
EngineModel model = compiler.compile(Paths.get("rules.json"));
----

3. **Evaluate an event**:
+
[source,java]
----
RuleEvaluator evaluator = new RuleEvaluator(model);

Event event = new Event("evt-123", "ORDER", Map.of(
    "order_amount", 15000,
    "customer_tier", "PLATINUM",
    "country", "US"
));

MatchResult result = evaluator.evaluate(event);
System.out.println("Matched rules: " + result.matchedRules());
----

---

== Rule Format

=== Basic Structure

Rules are defined in JSON format with the following schema:

[source,json]
----
{
  "rule_code": "UNIQUE_RULE_ID",           // Required: Unique identifier
  "priority": 100,                         // Optional: Default 0 (higher = higher priority)
  "description": "Human-readable desc",    // Optional: For documentation
  "enabled": true,                         // Optional: Default true
  "conditions": [                          // Required: Array of conditions
    {
      "field": "field_name",               // Field to check
      "operator": "EQUAL_TO",              // Comparison operator
      "value": "expected_value"            // Value to compare against
    }
  ]
}
----

=== Supported Operators

[cols="2,3,2,3"]
|===
|Operator |Description |Value Type |Example

|`EQUAL_TO`
|Exact match
|String, Number, Boolean
|`{"field": "status", "operator": "EQUAL_TO", "value": "ACTIVE"}`

|`NOT_EQUAL_TO`
|Not equal
|String, Number, Boolean
|`{"field": "type", "operator": "NOT_EQUAL_TO", "value": "SPAM"}`

|`GREATER_THAN`
|Numeric comparison >
|Number
|`{"field": "amount", "operator": "GREATER_THAN", "value": 1000}`

|`GREATER_THAN_OR_EQUAL`
|Numeric comparison >=
|Number
|`{"field": "score", "operator": "GREATER_THAN_OR_EQUAL", "value": 70}`

|`LESS_THAN`
|Numeric comparison <
|Number
|`{"field": "age", "operator": "LESS_THAN", "value": 18}`

|`LESS_THAN_OR_EQUAL`
|Numeric comparison <=
|Number
|`{"field": "risk", "operator": "LESS_THAN_OR_EQUAL", "value": 5}`

|`BETWEEN`
|Range check (inclusive)
|Array [min, max]
|`{"field": "price", "operator": "BETWEEN", "value": [10, 100]}`

|`IS_ANY_OF`
|Match any value in list (OR)
|Array
|`{"field": "country", "operator": "IS_ANY_OF", "value": ["US", "CA", "UK"]}`

|`CONTAINS`
|String contains substring
|String
|`{"field": "email", "operator": "CONTAINS", "value": "@example.com"}`

|`REGEX`
|Regular expression match
|String (regex pattern)
|`{"field": "phone", "operator": "REGEX", "value": "^\\+1-\\d{3}-\\d{4}$"}`
|===

=== Rule Examples

==== Simple Rule

[source,json]
----
{
  "rule_code": "ACTIVE_USERS",
  "conditions": [
    {"field": "status", "operator": "EQUAL_TO", "value": "ACTIVE"}
  ]
}
----

==== Multi-Condition Rule (AND Logic)

All conditions must match:

[source,json]
----
{
  "rule_code": "PREMIUM_HIGH_VALUE",
  "priority": 50,
  "conditions": [
    {"field": "tier", "operator": "EQUAL_TO", "value": "PREMIUM"},
    {"field": "amount", "operator": "GREATER_THAN", "value": 5000},
    {"field": "verified", "operator": "EQUAL_TO", "value": true}
  ]
}
----

==== Rule with Expansion (OR Logic via IS_ANY_OF)

[source,json]
----
{
  "rule_code": "INTERNATIONAL_ORDER",
  "conditions": [
    {"field": "country", "operator": "IS_ANY_OF", "value": ["UK", "FR", "DE", "IT", "ES"]},
    {"field": "amount", "operator": "GREATER_THAN", "value": 100}
  ]
}
----

**Note:** `IS_ANY_OF` with N values expands into N separate rule combinations internally. This rule becomes 5 combinations (one per country), all tagged with the same `rule_code`.

==== Complex Rule with Range

[source,json]
----
{
  "rule_code": "MID_RANGE_CUSTOMER",
  "description": "Customers with medium transaction history",
  "conditions": [
    {"field": "transaction_count", "operator": "BETWEEN", "value": [10, 100]},
    {"field": "account_age_days", "operator": "GREATER_THAN", "value": 30},
    {"field": "risk_score", "operator": "LESS_THAN", "value": 50}
  ]
}
----

==== Rule with Regex

[source,json]
----
{
  "rule_code": "CORPORATE_EMAIL",
  "conditions": [
    {"field": "email", "operator": "REGEX", "value": ".*@(company\\.com|corp\\.company\\.com)$"}
  ]
}
----

---

== Working with Events

=== Event Structure

Events are the data you evaluate against rules:

[source,java]
----
Event event = new Event(
    "unique-event-id",      // Event ID (required)
    "EVENT_TYPE",           // Event type (optional, used for routing)
    Map.of(                 // Attributes (field-value pairs)
        "field1", "value1",
        "field2", 42,
        "field3", true
    )
);
----

=== Event Attribute Types

Events support these attribute types:

* **String:** `"status": "ACTIVE"`
* **Integer:** `"amount": 1000`
* **Long:** `"timestamp": 1234567890L`
* **Double:** `"price": 99.99`
* **Boolean:** `"verified": true`

**Important:** Field names and string values are automatically uppercased and normalized (hyphens â†’ underscores) during evaluation for consistency.

=== Event Examples

==== E-commerce Order Event

[source,java]
----
Event orderEvent = new Event("order-12345", "ORDER_PLACED", Map.of(
    "customer_id", "cust-999",
    "order_amount", 15750,
    "currency", "USD",
    "customer_tier", "PLATINUM",
    "country", "US",
    "product_category", "ELECTRONICS",
    "payment_method", "CREDIT_CARD"
));
----

==== User Activity Event

[source,java]
----
Event activityEvent = new Event("activity-456", "USER_LOGIN", Map.of(
    "user_id", "user-789",
    "ip_address", "192.168.1.1",
    "device_type", "MOBILE",
    "login_count_today", 3,
    "account_age_days", 45,
    "is_verified", true
));
----

==== Fraud Detection Event

[source,java]
----
Event fraudEvent = new Event("txn-999", "TRANSACTION", Map.of(
    "transaction_amount", 50000,
    "merchant_category", "GAMBLING",
    "country", "XX",
    "velocity_last_hour", 12,
    "device_fingerprint_matches", false,
    "risk_score", 85
));
----

---

== Importing and Managing Rulesets

=== Loading Rules from File

[source,java]
----
import os.toolset.ruleengine.core.RuleCompiler;
import os.toolset.ruleengine.core.EngineModel;
import java.nio.file.Paths;

RuleCompiler compiler = new RuleCompiler(tracer);
EngineModel model = compiler.compile(Paths.get("rules.json"));
----

=== Loading Rules from String

[source,java]
----
String rulesJson = """
[
  {
    "rule_code": "TEST_RULE",
    "conditions": [
      {"field": "status", "operator": "EQUAL_TO", "value": "ACTIVE"}
    ]
  }
]
""";

Path tempFile = Files.createTempFile("rules", ".json");
Files.writeString(tempFile, rulesJson);
EngineModel model = compiler.compile(tempFile);
Files.delete(tempFile);
----

=== Hot Reload (Production)

Automatically reload rules when the file changes:

[source,java]
----
EngineModelManager manager = new EngineModelManager(
    Paths.get("rules.json"),
    tracer
);
manager.start();  // Starts background file watcher

// Get current model (atomic, thread-safe)
RuleEvaluator evaluator = new RuleEvaluator(manager.getEngineModel());

// On shutdown
manager.shutdown();
----

**How it works:**
1. Background thread monitors `rules.json` for changes
2. When file changes, new model is compiled in background
3. Once ready, atomic swap to new model
4. Zero downtime, in-flight evaluations continue with old model

=== Best Practices for Rule Management

==== 1. Use Descriptive Rule Codes

[source,json]
----
// Good
"rule_code": "FRAUD_HIGH_VELOCITY_INTL"

// Bad
"rule_code": "RULE_17"
----

==== 2. Set Appropriate Priorities

Higher priority rules are checked first when multiple rules match:

[source,json]
----
{
  "rule_code": "CRITICAL_FRAUD_ALERT",
  "priority": 1000,  // Highest priority
  "conditions": [...]
},
{
  "rule_code": "STANDARD_VALIDATION",
  "priority": 10,    // Lower priority
  "conditions": [...]
}
----

==== 3. Use Descriptions for Complex Rules

[source,json]
----
{
  "rule_code": "COMPLEX_RISK_CALC",
  "description": "Flags transactions >$10K from new accounts (<30 days) in high-risk countries",
  "conditions": [...]
}
----

==== 4. Disable Rules Instead of Deleting

[source,json]
----
{
  "rule_code": "OLD_PROMO_RULE",
  "enabled": false,  // Disabled but preserved for audit
  "conditions": [...]
}
----

==== 5. Optimize for Deduplication

Group similar rules together to maximize deduplication:

[source,json]
----
// These 3 rules will deduplicate into ~1 internal rule
[
  {
    "rule_code": "US_HIGH_VALUE",
    "conditions": [
      {"field": "country", "operator": "EQUAL_TO", "value": "US"},
      {"field": "amount", "operator": "GREATER_THAN", "value": 5000}
    ]
  },
  {
    "rule_code": "UK_HIGH_VALUE",
    "conditions": [
      {"field": "country", "operator": "EQUAL_TO", "value": "UK"},
      {"field": "amount", "operator": "GREATER_THAN", "value": 5000}
    ]
  },
  {
    "rule_code": "CA_HIGH_VALUE",
    "conditions": [
      {"field": "country", "operator": "EQUAL_TO", "value": "CA"},
      {"field": "amount", "operator": "GREATER_THAN", "value": 5000}
    ]
  }
]
----

Better alternative using `IS_ANY_OF`:

[source,json]
----
{
  "rule_code": "INTL_HIGH_VALUE",
  "conditions": [
    {"field": "country", "operator": "IS_ANY_OF", "value": ["US", "UK", "CA"]},
    {"field": "amount", "operator": "GREATER_THAN", "value": 5000}
  ]
}
----

---

== Adding Support for New Event Types

=== Step 1: Define Your Event Schema

Document the fields your events will have:

[source,yaml]
----
# customer_event_schema.yaml
event_type: CUSTOMER_EVENT
fields:
  - name: customer_id
    type: string
    required: true
  - name: account_balance
    type: number
  - name: loyalty_tier
    type: string
    values: [BRONZE, SILVER, GOLD, PLATINUM]
  - name: is_verified
    type: boolean
----

=== Step 2: Create Events

[source,java]
----
public class CustomerEventFactory {
    public static Event createCustomerEvent(
        String customerId,
        double accountBalance,
        String loyaltyTier,
        boolean isVerified
    ) {
        return new Event(
            "customer-" + customerId,
            "CUSTOMER_EVENT",
            Map.of(
                "customer_id", customerId,
                "account_balance", accountBalance,
                "loyalty_tier", loyaltyTier,
                "is_verified", isVerified
            )
        );
    }
}
----

=== Step 3: Create Rules for Your Event Type

[source,json]
----
[
  {
    "rule_code": "PREMIUM_CUSTOMER",
    "conditions": [
      {"field": "loyalty_tier", "operator": "IS_ANY_OF", "value": ["GOLD", "PLATINUM"]},
      {"field": "account_balance", "operator": "GREATER_THAN", "value": 10000},
      {"field": "is_verified", "operator": "EQUAL_TO", "value": true}
    ]
  }
]
----

=== Step 4: Evaluate

[source,java]
----
Event event = CustomerEventFactory.createCustomerEvent(
    "cust-123",
    15000.0,
    "PLATINUM",
    true
);

MatchResult result = evaluator.evaluate(event);
// result.matchedRules() contains ["PREMIUM_CUSTOMER"]
----

---

== Performance Tuning

=== Cache Configuration

The engine uses Caffeine cache for predicate evaluation results. Configure in `RuleEvaluator` initialization:

[source,java]
----
// In RuleEvaluator constructor (around line 45)
BaseConditionCache cache = new CaffeineBaseConditionCache.builder()
    .maxSize(100_000)                           // Adjust based on memory
    .expireAfterWrite(10, TimeUnit.MINUTES)     // TTL for cache entries
    .recordStats(true)                          // Enable monitoring
    .initialCapacity(10_000)                    // Pre-allocate
    .build();
----

**Tuning Guidelines:**
* `maxSize`: ~1000 per rule is a good starting point
* For 5000 rules: start with 100K-500K max size
* Monitor hit rate (should be >70% for good performance)

=== Monitoring Cache Performance

[source,java]
----
if (cache instanceof CaffeineBaseConditionCache) {
    CaffeineBaseConditionCache caffeineCache = (CaffeineBaseConditionCache) cache;
    var stats = caffeineCache.getCaffeineStats();

    logger.info("Cache hit rate: {}%", stats.hitRate() * 100);
    logger.info("Cache size: {}", caffeineCache.estimatedSize());
    logger.info("Evictions: {}", stats.evictionCount());
}
----

=== Benchmark Your Rules

[source,bash]
----
# Run the cliff analysis benchmark
mvn test-compile exec:java \
  -Dexec.mainClass="os.toolset.ruleengine.benchmark.GranularCliffBenchmark" \
  -Dexec.classpathScope=test

# Expected output:
# Rule Count 500:  ~5Âµs per evaluation
# Rule Count 2000: ~5Âµs per evaluation (should be similar, no cliff)
# Rule Count 5000: ~5Âµs per evaluation
----

=== Optimal JVM Settings

[source,bash]
----
java -Xms8g -Xmx8g \
     -XX:+UseZGC \
     -XX:+ZGenerational \
     -XX:+AlwaysPreTouch \
     -jar rule-engine.jar
----

---

== Troubleshooting

=== Rules Not Matching

**Problem:** Events that should match don't match any rules.

**Solutions:**

1. **Check field name normalization:**
+
[source,java]
----
// Fields are automatically uppercased and normalized
// Event field:       "customer-tier" â†’ "CUSTOMER_TIER"
// Rule field should: "customer_tier" â†’ "CUSTOMER_TIER"
----

2. **Verify data types:**
+
[source,json]
----
// Wrong: String "1000" won't match number condition
{"field": "amount", "operator": "GREATER_THAN", "value": 1000}

// Event should have: "amount": 1000 (number, not string)
----

3. **Enable debug logging:**
+
[source,java]
----
Logger.getLogger("os.toolset.ruleengine").setLevel(Level.FINE);
----

=== Performance Degradation

**Problem:** Evaluation latency increases over time.

**Solutions:**

1. **Check cache hit rate:**
+
[source,java]
----
// Should be >70%
double hitRate = cache.getCaffeineStats().hitRate();
if (hitRate < 0.70) {
    logger.warn("Low cache hit rate: {}%", hitRate * 100);
    // Increase cache size or adjust TTL
}
----

2. **Monitor GC:**
+
[source,bash]
----
# Add GC logging
-Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=100m
----

3. **Check rule expansion:**
+
[source,java]
----
Map<String, Object> stats = model.getStats().metadata();
int expanded = (int) stats.get("totalExpandedCombinations");
int unique = (int) stats.get("uniqueCombinations");
double dedup = (double) stats.get("deduplicationRatePercent");

// High expansion with low dedup is problematic
if (expanded > 100000 && dedup < 50.0) {
    logger.warn("High expansion with low dedup: {}% dedup", dedup);
}
----

=== Compilation Errors

**Problem:** Rules fail to compile.

**Common Issues:**

1. **Invalid JSON:**
+
[source,bash]
----
# Validate JSON
cat rules.json | jq .
----

2. **Unknown operator:**
+
[source,json]
----
// Wrong
{"field": "amount", "operator": "BIGGER_THAN", "value": 100}

// Correct
{"field": "amount", "operator": "GREATER_THAN", "value": 100}
----

3. **Type mismatch:**
+
[source,json]
----
// Wrong: String value for numeric operator
{"field": "amount", "operator": "GREATER_THAN", "value": "1000"}

// Correct: Numeric value
{"field": "amount", "operator": "GREATER_THAN", "value": 1000}
----

---

== API Reference

=== Core Classes

==== RuleCompiler

Compiles JSON rules into an optimized EngineModel.

[source,java]
----
RuleCompiler compiler = new RuleCompiler(tracer);
EngineModel model = compiler.compile(Path.of("rules.json"));
----

==== RuleEvaluator

Evaluates events against compiled rules.

[source,java]
----
RuleEvaluator evaluator = new RuleEvaluator(model, tracer, true);
MatchResult result = evaluator.evaluate(event);
----

==== Event

Represents an event to evaluate.

[source,java]
----
Event event = new Event(
    String eventId,           // Unique event identifier
    String eventType,         // Event type (for routing)
    Map<String, Object> attrs // Event attributes
);
----

==== MatchResult

Contains evaluation results.

[source,java]
----
record MatchResult(
    String eventId,                      // Event that was evaluated
    List<MatchedRule> matchedRules,      // Rules that matched
    long evaluationTimeNanos,            // Time taken
    int predicatesEvaluated,             // Number of predicates checked
    int rulesEvaluated                   // Number of rules checked
) {
    record MatchedRule(
        int ruleId,
        String ruleCode,
        int priority,
        String description
    ) {}
}
----

---

== Examples

=== Complete Example: Fraud Detection System

[source,java]
----
import os.toolset.ruleengine.core.*;
import os.toolset.ruleengine.model.*;
import java.nio.file.*;
import java.util.*;

public class FraudDetectionExample {
    public static void main(String[] args) throws Exception {
        // 1. Create rules
        String rulesJson = """
        [
          {
            "rule_code": "HIGH_RISK_COUNTRY",
            "priority": 100,
            "description": "Transaction from high-risk country",
            "conditions": [
              {"field": "country", "operator": "IS_ANY_OF",
               "value": ["XX", "YY", "ZZ"]},
              {"field": "amount", "operator": "GREATER_THAN", "value": 1000}
            ]
          },
          {
            "rule_code": "VELOCITY_CHECK",
            "priority": 90,
            "description": "Too many transactions in short time",
            "conditions": [
              {"field": "transactions_last_hour", "operator": "GREATER_THAN",
               "value": 10},
              {"field": "average_amount", "operator": "GREATER_THAN",
               "value": 500}
            ]
          },
          {
            "rule_code": "NEW_ACCOUNT_LARGE_PURCHASE",
            "priority": 80,
            "conditions": [
              {"field": "account_age_days", "operator": "LESS_THAN", "value": 7},
              {"field": "amount", "operator": "GREATER_THAN", "value": 5000}
            ]
          }
        ]
        """;

        Path rulesFile = Files.createTempFile("fraud_rules", ".json");
        Files.writeString(rulesFile, rulesJson);

        // 2. Compile rules
        RuleCompiler compiler = new RuleCompiler(
            TracingService.getInstance().getTracer()
        );
        EngineModel model = compiler.compile(rulesFile);

        System.out.println("Compiled " + model.getStats().metadata()
            .get("logicalRules") + " rules");

        // 3. Create evaluator
        RuleEvaluator evaluator = new RuleEvaluator(model);

        // 4. Evaluate suspicious transaction
        Event suspiciousTransaction = new Event(
            "txn-999",
            "TRANSACTION",
            Map.of(
                "country", "XX",
                "amount", 15000,
                "transactions_last_hour", 12,
                "average_amount", 800,
                "account_age_days", 3
            )
        );

        MatchResult result = evaluator.evaluate(suspiciousTransaction);

        // 5. Process results
        System.out.println("\nEvaluation Results:");
        System.out.println("==================");
        System.out.println("Event ID: " + result.eventId());
        System.out.println("Evaluation time: " +
            result.evaluationTimeNanos() / 1000.0 + " Âµs");
        System.out.println("\nMatched Rules:");

        result.matchedRules().stream()
            .sorted(Comparator.comparingInt(r -> -r.priority()))
            .forEach(rule -> {
                System.out.println("  - " + rule.ruleCode() +
                    " (priority: " + rule.priority() + ")");
                if (rule.description() != null) {
                    System.out.println("    " + rule.description());
                }
            });

        // Expected output:
        // - HIGH_RISK_COUNTRY (priority: 100)
        // - VELOCITY_CHECK (priority: 90)
        // - NEW_ACCOUNT_LARGE_PURCHASE (priority: 80)

        Files.delete(rulesFile);
    }
}
----

---

== Additional Resources

* **Architecture Deep Dive:** See `Ruleenginespec_v1.pdf` for detailed design
* **Performance Benchmarks:** Run `SimpleBenchmark` and `GranularCliffBenchmark`
* **API Documentation:** Generate with `mvn javadoc:javadoc`
* **Source Code:** https://github.com/your-org/helios-rule-engine

---

== License

Copyright Â© 2025. All rights reserved.